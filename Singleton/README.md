# Паттерн Singleton (одиночка)
## Название и классификация паттерна
**Одиночка** — паттерн, порождающий объекты.
## Назначение
Гарантирует, что у класса существует только один экземпляр, и предоставляет к нему глобальную точку доступа.
## Мотивация
Для некоторых классов важно, чтобы существовал только один экземпляр.
В системе может быть много принтеров, но может существовать лишь один
спулер. В операционной системе должна быть только одна файловая система
и единственный оконный менеджер. В цифровом фильтре может находиться только один аналого-цифровой преобразователь (АЦП). Бухгалтерская
система обслуживает только одну компанию.

Как гарантировать, что у класса есть единственный экземпляр и что этот
экземпляр легко доступен? Глобальная переменная дает доступ к объекту,
но не запрещает создать несколько экземпляров класса.

Более удачное решение — возложить на сам класс ответственность за то, что
у него существует только один экземпляр. Класс может запретить создание
дополнительных экземпляров, перехватывая запросы на создание новых
объектов, и он же способен предоставить доступ к своему экземпляру. Это
и есть назначение паттерна **одиночка**.
## Применимость
Основные условия для применения паттерна **одиночка**:
*	должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа;
*	единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность работать с расширенным экземпляром без модификации своего кода.
## Структура

ИЗОБРАЖЕНИЕ
## Участники
*	`Singleton` — одиночка:
	*	определяет операцию `Instance`, которая позволяет клиентам получить
доступ к единственному экземпляру. `Instance` — это операция класса,
то есть метод класса в терминологии Smalltalk и статическая функция
класса в C++;
	*	может нести ответственность за создание собственного уникального
экземпляра.
## Отношения
Клиенты получают доступ к экземпляру класса `Singleton` только через его
операцию `Instance`.
## Результаты
Паттерн **одиночка** обладает рядом достоинств:
*	*контролируемый доступ к единственному экземпляру*. Поскольку класс
`Singleton` инкапсулирует свой единственный экземпляр, он полностью
контролирует то, как и когда клиенты получают доступ к нему;
*	*сокращение пространства имен*. Паттерн **одиночка** — шаг вперед по сравнению с глобальными переменными. Он позволяет избежать засорения
пространства имен глобальными переменными, в которых хранятся
уникальные экземпляры;
*	*возможность уточнения операций и представления*. От класса `Singleton`
можно порождать подклассы, а приложение легко настраивается экземпляром расширенного класса. Приложение можно настроить экземпляром нужного класса во время выполнения;
*	*возможность использования переменного числа экземпляров*. Паттерн позволяет легко изменить решение и разрешить появление более одного
экземпляра класса `Singleton`. Более того, тот же подход может использоваться для управления числом экземпляров, используемых в приложении. Изменить нужно будет лишь операцию, дающую доступ к экземпляру класса `Singleton`;
*	*большая гибкость, чем у операций класса*. Другой способ реализации
функциональности **одиночки** — использование операций класса, то есть
статических функций класса в C++ и методов класса в Smalltalk. Но оба
этих приема препятствуют изменению дизайна, если потребуется разрешить наличие нескольких экземпляров класса. Кроме того, статические
функции классов в C++ не могут быть виртуальными, что делает невозможной их полиморфную замену в подклассах.
## Реализация
При использовании паттерна **одиночка** надо рассмотреть следующие вопросы:
*	*гарантии существования единственного экземпляра*. Паттерн **одиночка**
устроен так, что тот единственный экземпляр, который имеется у класса, — самый обычный, но сам класс написан так, что больше одного экземпляра создать не удастся. Чаще всего для этого операция, создающая
экземпляры, скрывается за операцией класса (то есть за статической
функцией или методом класса), которая гарантирует создание не более
одного экземпляра. Данная операция имеет доступ к переменной, где
хранится уникальный экземпляр, и гарантирует инициализацию переменной этим экземпляром перед возвратом ее клиенту. При таком подходе можно не сомневаться, что **одиночка** будет создан и инициализирован перед первым использованием.

	В C++ операция класса определяется с помощью статической функции
`Instance` класса `Singleton`. В этот класс также включена статическая переменная `_instance`, которая содержит указатель на уникальный экземпляр.

	Класс `Singleton` объявлен следующим образом:
	```cpp
	class Singleton {
	public:
		static Singleton* Instance();
	protected:
		Singleton();
	private:
		static Singleton* _instance;
	};
	```
	Соответствующая реализация выглядит так:
	```cpp
	Singleton* Singleton::_instance = 0;
	Singleton* Singleton::Instance () {
		if (_instance == 0) {
			_instance = new Singleton;
		}
		return _instance;
	}
	```
	Клиенты осуществляют доступ к одиночке исключительно через функцию `Instance`. Переменная `_instance` инициализируется нулем, а статическая функция `Instance` возвращает ее значение, инициализируя ее
	уникальным экземпляром, если в текущий момент оно равно `0`. Функция `Instance` использует отложенную инициализацию: возвращаемое
	ей значение не создается и не сохраняется вплоть до момента первого
	обращения.

	Обратите внимание, что конструктор защищенный. Клиент, который
	попытается создать экземпляр класса `Singleton` непосредственно, получит ошибку на этапе компиляции. Тем самым гарантируется, что будет
	создан только один экземпляр.

	Далее, поскольку `_instance` — указатель на объект класса `Singleton`, то
	функция `Instance` может присвоить этой переменной указатель на любой
	подкласс данного класса. Применение возможности мы увидим в разделе
	[«Пример кода»](#пример-кода).

	О реализации в C++ стоит сказать особо. Недостаточно определить рассматриваемый паттерн как глобальный или статический объект, а затем
	полагаться на автоматическую инициализацию. Тому есть три причины:
	*	невозможно гарантировать, что в программе будет объявлен только
	один экземпляр статического объекта;
	*	у нас может не быть достаточно информации для создания экземпляра
	каждого **одиночки** во время статической инициализации. **Одиночке** могут потребоваться данные, вычисляемые позже, во время выполнения
	программы;
	*	в С++ не определяется порядок вызова конструкторов для глобальных
	объектов через границы единиц трансляции \[ES90\]. Это означает, что
	между одиночками не может существовать никаких зависимостей.
	Если они есть, то ошибок не избежать.

	Еще один недостаток глобальных/статических объектов в том, что приходится создавать всех одиночек, даже если они не используются. Применение статической функции класса решает эту проблему.

	В Smalltalk функция, возвращающая уникальный экземпляр, реализуется как метод класса Singleton. Чтобы гарантировать единственность
	экземпляра, следует заместить операцию `new`. Получающийся класс мог
	бы иметь два метода класса (в них `SoleInstance` — это переменная класса,
	которая больше нигде не используется):
	```smalltalk
	new
		self error: 'cannot create new object'

	default
		SoleInstance isNil ifTrue: [SoleInstance := super new].
		^ SoleInstance
	```
*	*Порождение подклассов Singleton*. Основной вопрос не столько в том,
как определить подкласс, а в том, как оформить его уникальный экземпляр, чтобы клиенты могли использовать его. По существу, переменная,
ссылающаяся на экземпляр одиночки, должна инициализироваться
вместе с экземпляром подкласса. Простейший способ добиться этого —
определить одиночку, которого нужно применять в операции Instance
класса Singleton. В разделе [«Пример кода»](#пример-кода) показывается, как можно
реализовать эту технику с помощью переменных среды.

	Другой способ выбора подкласса `Singleton` — вынести реализацию
операции `Instance` из родительского класса (например, `MazeFactory`)
и поместить ее в подкласс. Это позволит программисту на C++ задать
класс **одиночки** на этапе компоновки (например, скомпоновав программу
с объектным файлом, содержащим другую реализацию), но от клиента
**одиночка** будет по-прежнему скрыт.

	Такой подход фиксирует выбор класса **одиночки** на этапе компоновки,
затрудняя тем самым его подмену во время выполнения. Применение
условных операторов для выбора подкласса увеличивает гибкость решения, но все равно множество возможных классов `Singleton` остается
жестко «зашитым» в код. В общем случае ни тот, ни другой подход не
обеспечивают достаточной гибкости.

	Ее можно добиться за счет использования реестра **одиночек**. Вместо того
чтобы задавать множество возможных классов `Singleton` в операции
`Instance`, **одиночки** могут регистрировать себя по имени в некотором
всем известном реестре.

	Реестр сопоставляет **одиночкам** строковые имена. Когда операции
`Instance` нужен некоторый **одиночка**, она запрашивает его у реестра по
имени. Начинается поиск указанного **одиночки**, и, если он существует,
реестр возвращает его. Такой подход освобождает `Instance` от необходимости «знать» все возможные классы или экземпляры `Singleton`. Нужен лишь единый для всех классов `Singleton` интерфейс, включающий
операции с реестром:
	```cpp
	class Singleton {
	public:
		static void Register(const char* name, Singleton*);
		static Singleton* Instance();
	protected:
		static Singleton* Lookup(const char* name);
	private:
		static Singleton* _instance;
		static List<NameSingletonPair>* _registry;
	};
	```
	Операция `Register` регистрирует экземпляр класса `Singleton` под указанным именем. Чтобы не усложнять реестр, мы будем хранить его в виде
списка объектов `NameSingletonPair`. Каждый такой объект устанавливает
соответствие между именем и одиночкой. Операция `Lookup` ищет одиночку по имени. Допустим, имя нужного одиночки передается в переменной
среды:
	```cpp
	Singleton* Singleton::Instance () {
		if (_instance == 0) {
			const char* singletonName = getenv("SINGLETON");
			// Задается пользователем или средой при запуске

			_instance = Lookup(singletonName);
			// Lookup возвращает 0, если такой одиночка не найден.
		}
		return _instance;
	}
	```
	В какой момент классы `Singleton` регистрируют себя? Одна из возможностей — конструктор. Например, подкласс `MySingleton` мог бы работать так:
	```cpp
	MySingleton::MySingleton() {
		// ...
		Singleton::Register("MySingleton", this);
	}
	```
	Разумеется, конструктор не будет вызван, пока кто-то не создаст экземпляр
класса, но ведь это та самая проблема, которую паттерн одиночка ипытается
разрешить! В C++ ее можно попытаться обойти, определив статический
экземпляр класса `MySingleton`. Например, можно вставить строку
	```cpp
	static MySingleton theSingleton;
	```
	в файл с реализацией MySingleton.

	Теперь класс `Singleton` не отвечает за создание одиночки. Его основной
обязанностью становится обеспечение доступа к объекту-одиночке из любой части системы. Решение со статическим объектом по-прежнему имеет
потенциальный недостаток: необходимость создания экземпляров всех
возможных подклассов `Singleton`, без чего они не будут зарегистрированы.
## Пример кода
Предположим, нам надо определить класс `MazeFactory` для создания лабиринтов, описанный на с. 111. `MazeFactory` определяет интерфейс для
построения различных частей лабиринта. В подклассах эти операции могут
переопределяться, чтобы возвращать экземпляры специализированных
классов продуктов, например объекты `BombedWall`, а не просто `Wall`.

Существенно здесь то, что приложению `Maze` нужен лишь один экземпляр
фабрики лабиринтов и он должен быть доступен в коде, строящем любую
часть лабиринта. Тут-то паттерн **одиночка** и приходит на помощь. Сделав
фабрику `MazeFactory` одиночкой, мы сможем обеспечить глобальную доступность объекта, представляющего лабиринт, не прибегая к глобальным
переменным.

Для простоты предположим, что мы никогда не порождаем подклассов от
`MazeFactory`. (Чуть ниже будет рассмотрен альтернативный подход.) В C++
для того, чтобы превратить фабрику в одиночку, мы добавляем в класс
`MazeFactory` статическую операцию `Instance` и статический член `_instance`,
в котором будет храниться единственный экземпляр. Нужно также сделать
конструктор защищенным, чтобы предотвратить случайное создание экземпляра, в результате которого будет создан лишний экземпляр:
```cpp
class MazeFactory {
public:
	static MazeFactory* Instance();

	// Здесь находится существующий интерфейс
protected:
	MazeFactory();
private:
	static MazeFactory* _instance;
};
```
Соответствующая реализация выглядит так:
```cpp
MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
	if (_instance == 0) {
		_instance = new MazeFactory;
	}
	return _instance;
}
```
Теперь посмотрим, что случится, когда у `MazeFactory` есть подклассы и определяется, какой из них использовать. Вид лабиринта мы будем выбирать
с помощью переменной среды, поэтому добавим код, который создает экземпляр нужного подкласса `MazeFactory` в зависимости от значения данной
переменной. Лучше всего поместить код в операцию `Instance`, поскольку
она уже и так создает экземпляр `MazeFactory`:
```cpp
MazeFactory* MazeFactory::Instance () {
	if (_instance == 0) {
		const char* mazeStyle = getenv("MAZESTYLE");

		if (strcmp(mazeStyle, "bombed") == 0) {
			_instance = new BombedMazeFactory;

		} else if (strcmp(mazeStyle, "enchanted") == 0) {
			_instance = new EnchantedMazeFactory;

		// ...другие возможные подклассы

		} else { // по умолчанию
			_instance = new MazeFactory;
		}
	}
	return _instance;
}
```
Отметим, что операцию `Instance` придется модифицировать при определении каждого нового подкласса `MazeFactory`. Возможно, в данном приложении
это не создаст проблем, но для абстрактных фабрик, определенных в каркасе,
такой подход трудно назвать приемлемым.

Одно из решений — воспользоваться принципом реестра, описанным в разделе [«Реализация»](#реализация). Может помочь и динамическое связывание, тогда приложению не нужно будет загружать все неиспользуемые подклассы.
## Известные применения
Примером паттерна **одиночка** в Smalltalk 80 \[Par90\] является множество
изменений кода, представленное классом `ChangeSet`. Более тонкий пример —
это отношение между классами и их *метаклассами*. Метаклассом называется
класс класса, каждый метакласс существует в единственном экземпляре.
У метакласса нет имени (разве что косвенное, определяемое экземпляром),
но он контролирует свой уникальный экземпляр, и создать второй обычно
не разрешается.

В библиотеке InterViews, предназначенной для создания пользовательских
интерфейсов \[LCI+92\], паттерн **одиночка** применяется для доступа к единственным экземплярам классов `Session` (сессия) и `WidgetKit` (набор виджетов). Классом `Session` определяется главный цикл событий в приложении.
Он хранит пользовательские настройки стиля и управляет подключением
к одному или нескольким физическим дисплеям. `WidgetKit` — это **абстрактная фабрика** для определения внешнего облика интерфейсных виджетов. Операция `WidgetKit::instance()` определяет конкретный подкласс
`WidgetKit` для создания экземпляра на основании переменной среды, которую определяет `Session`. Аналогичная операция в классе `Session` «выясняет»,
поддерживаются ли монохромные или цветные дисплеи, и соответственно
настраивает конфигурацию одиночного экземпляра `Session`.
## Родственные паттерны
С помощью паттерна **одиночка** могут быть реализованы многие паттерны. См.
описания **абстрактной фабрики**, **строителя** и **прототипа**.