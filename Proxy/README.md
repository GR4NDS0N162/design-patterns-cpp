# Паттерн Proxy (заместитель)

## Название и классификация паттерна

**Заместитель** — паттерн, структурирующий объекты.

## Назначение

Является суррогатом другого объекта и контролирует доступ к нему.

## Другие названия

**Surrogate** (суррогат).

## Мотивация

Одна из причин для управления доступом к объекту — возможность отложить затраты на создание и инициализацию до момента, когда возникнет фактическая необходимость в объекте. Рассмотрим редактор документов, в котором в документы могут встраиваться графические объекты. Затраты на создание некоторых таких объектов (например, больших растровых изображений) могут быть весьма значительными. Но документ должен открываться быстро, поэтому следует избегать создания всех «тяжелых» объектов на стадии открытия (и вообще это излишне, поскольку не все они будут видны одновременно).

В связи с такими ограничениями кажется разумным создавать «тяжелые» объекты *по требованию*. Это означает «когда изображение становится видимым». Но что поместить в документ вместо изображения? И как без усложнения реализации редактора скрыть тот факт, что изображение создается по требованию? Например, оптимизация не должна отражаться на коде, отвечающем за рисование и форматирование.

Решение состоит в том, чтобы использовать другой объект — *заместитель* изображения, который временно подставляется вместо реального изображения. Заместитель ведет себя точно так же, как само изображение, и при необходимости создает его экземпляр.

![image](https://user-images.githubusercontent.com/100960770/166919351-783120ed-0618-4417-bbf0-5d3f3b69826b.png)

**Заместитель** создает настоящее изображение, только если редактор документа вызовет операцию `Draw`. Все последующие запросы заместитель переадресует непосредственно изображению. Поэтому после создания изображения он должен сохранить ссылку на него.

Предположим, что изображения хранятся в отдельных файлах. В таком случае мы можем использовать имя файла как ссылку на реальный объект. Заместитель хранит также размер изображения, то есть длину и ширину. «Зная» ее, заместитель может отвечать на запросы форматера о своем размере, не создавая экземпляр изображения.

На следующей диаграмме классов этот пример показан более подробно.

![image](https://user-images.githubusercontent.com/100960770/166919456-201bbe8a-880f-4849-9a3e-8ad58fbcaca2.png)

Редактор документов получает доступ к встроенным изображениям только через интерфейс, определенный в абстрактном классе `Graphic`. `ImageProxy` — это класс для представления изображений, создаваемых по требованию. В `ImageProxy` хранится имя файла, играющее роль ссылки на изображение, которое находится на диске. Имя файла передается конструктору класса `ImageProxy`.

В объекте `ImageProxy` находятся также ограничивающий прямоугольник изображения и ссылка на экземпляр реального объекта `Image`. Ссылка остается недействительной, пока заместитель не создаст экземпляр реального изображения. Операция `Draw` гарантирует, что изображение будет создано до того, как заместитель переадресует ему запрос. Операция `GetExtent` переадресует запрос изображению, только если его экземпляр уже создан; в противном случае `ImageProxy` возвращает те размеры, которые хранит сам.

## Применимость

Паттерн **заместитель** применим во всех случаях, когда возникает необходимость сослаться на объект более гибким или нетривиальным способом, чем при использовании простого указателя. Несколько типичных ситуаций, в которых **заместитель** может оказаться полезным:

* *удаленный заместитель* предоставляет локального представителя для объекта, находящегося в другом адресном пространстве. В системе NEXTSTEP \[Add94\] для этой цели применяется класс `NXProxy`. Заместителя такого рода Джеймс Коплиен \[Cop92\] называет «послом» (Ambassador);
* *виртуальный заместитель* создает «тяжелые» объекты по требованию. Примером может служить класс `ImageProxy`, описанный в разделе [«Мотивация»](#мотивация);
* *защищающий заместитель* контролирует доступ к исходному объекту. Такие заместители полезны, когда для разных объектов определены различные права доступа. Например, в операционной системе Choices \[CIRM93\] объекты `KernelProxy` ограничивают права доступа к объектам операционной системы;
* *«умная» ссылка* — это замена обычного указателя. Она позволяет выполнить дополнительные действия при доступе к объекту. К типичным применениям такой ссылки можно отнести:

	* подсчет числа ссылок на реальный объект, с тем чтобы занимаемую им память можно было освободить автоматически, когда не останется ни одной ссылки (такие ссылки называют еще «умными» указателями \[Ede92\]);
	* загрузку объекта из долгосрочного хранилища в память при первом обращении к нему;
	* проверку и установку блокировки на реальный объект при обращении к нему, чтобы никакой другой объект не смог в это время изменить его.

## Структура

![image](https://user-images.githubusercontent.com/100960770/166919587-4cb32176-7ef2-4b6a-9f68-3385cc620386.png)

Вот как может выглядеть схема объектов для структуры с заместителем во время выполнения.

![image](https://user-images.githubusercontent.com/100960770/166919660-99e6080a-170b-444a-94de-ab7a51b15f05.png)

## Участники

* **Proxy** (`ImageProxy`) — заместитель:

	* хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту. Объект класса `Proxy` может обращаться к объекту класса `Subject`, если интерфейсы классов `RealSubject` и `Subject` одинаковы;
	* предоставляет интерфейс, идентичный интерфейсу `Subject`, так что заместитель всегда может быть подставлен вместо реального субъекта;
	* контролирует доступ к реальному субъекту и может отвечать за его создание и удаление;
	* прочие обязанности зависят от вида заместителя:

		* *удаленный заместитель* отвечает за кодирование запроса и его аргументов и отправление закодированного запроса реальному субъекту в другом адресном пространстве;
		* *виртуальный заместитель* может кэшировать дополнительную информацию о реальном субъекте, чтобы отложить его создание. Например, класс `ImageProxy` из раздела [«Мотивация»](#мотивация) кэширует размеры реального изображения;
		* *защищающий заместитель* проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права;

* **Subject** (`Graphic`) — субъект:

	* определяет общий для `RealSubject` и `Proxy` интерфейс, так что класс `Proxy` можно использовать везде, где ожидается `RealSubject`;

* **RealSubject** (`Image`) — реальный субъект:

	* определяет реальный объект, представленный заместителем.

## Отношения

`Proxy` при необходимости переадресует запросы объекту `RealSubject`. Детали зависят от вида заместителя.

## Результаты

С помощью паттерна **заместитель** при доступе к объекту вводится дополнительный уровень косвенности. У этого подхода есть много вариантов в зависимости от вида заместителя:

* удаленный заместитель может скрыть тот факт, что объект находится в другом адресном пространстве
* виртуальный заместитель может выполнять оптимизацию, например создание объекта по требованию;
* защищающий заместитель и «умная» ссылка позволяют решать дополнительные задачи при доступе к объекту.

Есть еще одна оптимизация, которую паттерн **заместитель** иногда скрывает от клиента. Она называется *копированием при записи* (copy-on-write) и имеет много общего с созданием объекта по требованию. Копирование большого и сложного объекта — очень затратная операция. Если копия не модифицировалась, то нет смысла эту цену платить. Если отложить процесс копирования, применив паттерн **заместитель**, то можно быть уверенным, что эта операция произойдет только тогда, когда он действительно был изменен.

Чтобы во время записи можно было копировать, необходимо подсчитывать ссылки на субъект. Копирование заместителя просто увеличивает счетчик ссылок. И только тогда, когда клиент запрашивает операцию, изменяющую субъект, заместитель действительно выполняет копирование. Одновременно заместитель должен уменьшить счетчик ссылок. Когда счетчик ссылок становится равным нулю, субъект уничтожается.

Копирование при записи может существенно уменьшить плату за копирование «тяжелых» субъектов.

## Реализация

При реализации паттерна заместитель можно использовать следующие возможности языка:

*	*перегрузку оператора обращения к членам класса в C++*. Язык C++ поддерживает перегрузку оператора обращения к членам класса `->`. Это позволяет производить дополнительные действия при любом разыменовании указателя на объект. Для реализации некоторых видов заместителей это оказывается полезно, поскольку заместитель ведет себя аналогично указателю.

	В следующем примере показано, как воспользоваться данным приемом для реализации виртуального заместителя `ImagePtr`:

	```cpp
	class Image;
	extern Image* LoadAnImageFile(const char*);
		// внешняя функция
	
	class ImagePtr {
	public:
		ImagePtr(const char* imageFile);
		virtual ~ImagePtr();
		virtual Image* operator->();
		virtual Image& operator*();
	private:
		Image* LoadImage();
	private:
		Image* _image;
		const char* _imageFile;
	};

	ImagePtr::ImagePtr(const char* theImageFile) {
		_imageFile = theImageFile;
		_image = 0;
	}

	Image* ImagePtr::LoadImage () {
		if (_image == 0) {
			_image = LoadAnImageFile(_imageFile);
		}
 	return _image;
	} 
	```

	Перегруженные операторы `->` и `*` используют операцию `LoadImage` для возврата клиенту изображения, хранящегося в переменной `_image` (при необходимости загрузив его):

	```cpp
	Image* ImagePtr::operator-> () {
		return LoadImage();
	}

	Image& ImagePtr::operator* () {
		return *LoadImage();
	}
	```

	Такой подход позволяет вызывать операции объекта `Image` через объекты `ImagePtr`, не заботясь о том, чтобы включить их в интерфейс данного класса:

	```cpp
	ImagePtr image = ImagePtr("anImageFileName");
	image->Draw(Point(50, 100));
		// (image.operator->())->Draw(Point(50, 100)
	```

	Обратите внимание, что заместитель изображения ведет себя подобно указателю, но не объявлен как указатель на `Image`. Это означает, что использовать его в точности как настоящий указатель на `Image` нельзя. Поэтому при таком подходе клиентам следует трактовать объекты `Image` и `ImagePtr` по-разному.

	Перегрузка оператора доступа не является лучшим решением для всех видов заместителей. Некоторым из них должно быть точно известно, *какая* операция вызывается, а в таких случаях перегрузка оператора доступа не работает.

	Возьмем пример виртуального заместителя, обсуждавшийся в разделе [«Мотивация»](#мотивация). Изображение нужно загружать в точно определенное время — при вызове операции `Draw`, а не при каждом обращении к нему.

	Перегрузка оператора доступа не позволяет различить подобные случаи. В такой ситуации придется вручную реализовать каждую операцию заместителя, переадресующую запрос субъекту.

	Обычно все эти операции очень похожи друг на друга, как видно из примера кода в одноименном разделе. Они проверяют, что запрос корректен, что объект-адресат существует и т. д., а потом уже перенаправляют ему запрос. Писать этот код снова и снова надоедает, поэтому нередко он автоматически генерируется препроцессором;

*	*метод doesNotUnderstand в Smalltalk*. В языке Smalltalk есть возможность, позволяющая автоматически поддерживать переадресацию запросов. При отправке клиентом сообщения, для которого у получателя нет соответствующего метода, Smalltalk вызывает метод `doesNotUnderstand: aMessage`. Заместитель может переопределить `doesNotUnderstand` так, что сообщение будет переадресовано субъекту.

	Чтобы гарантировать, что запрос будет перенаправлен субъекту, а не просто тихо поглощен заместителем, класс `Proxy` можно определить так, что он не станет понимать никаких сообщений. Smalltalk позволяет это сделать, надо лишь, чтобы у `Proxy` не было суперкласса.

	> Этот прием используется при реализации распределенных объектов в системе NEXTSTEP \[Add94\] (точнее, в классе `NXProxy`). Только там переопределяется метод `forward` — эквивалент описанного только что приема в Smalltalk.

	Главный недостаток метода `doesNotUnderstand`: в том, что в большинстве Smalltalk-систем имеется несколько специальных сообщений, обрабатываемых непосредственно виртуальной машиной, а в этом случае стандартный механизм поиска методов обходится. Правда, единственной такой операцией, написанной в классе `Object` (а следовательно, способной повлиять на заместителей), является тождество `==`.
	
	Если вы собираетесь применять `doesNotUnderstand`: для реализации заместителя, вышеописанная проблема должна быть как-то решена на уровне проектирования. Нельзя же ожидать, что совпадение заместителей равнозначно совпадению реальных субъектов. К сожалению, метод `doesNotUnderstand`: изначально создавался для обработки ошибок, а не для построения заместителей, поэтому его быстродействие оставляет желать лучшего;

*	*заместителю не всегда должен быть известен тип реального объекта*. Если класс `Proxy` может работать с субъектом только через его абстрактный интерфейс, то не нужно создавать Proxy для каждого класса реального субъекта `RealSubject`; заместитель может обращаться к любому из них единообразно. Но если заместитель должен создавать экземпляры реальных субъектов (как обстоит дело в случае виртуальных заместителей), то знание конкретного класса обязательно.

К проблемам реализации можно отнести и решение вопроса о том, как обращаться к субъекту, экземпляр которого еще не создан. Некоторые заместители должны обращаться к своим субъектам независимо от того, где они находятся — на диске или в памяти. Это означает, что нужно использовать какую-то форму идентификаторов объектов, не зависящих от адресного пространства. В разделе «Мотивация» для этой цели использовалось имя файла.
