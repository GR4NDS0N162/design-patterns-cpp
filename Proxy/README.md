# Паттерн Proxy (заместитель)

## Название и классификация паттерна

**Заместитель** — паттерн, структурирующий объекты.

## Назначение

Является суррогатом другого объекта и контролирует доступ к нему.

## Другие названия

**Surrogate** (суррогат).

## Мотивация

Одна из причин для управления доступом к объекту — возможность отложить затраты на создание и инициализацию до момента, когда возникнет фактическая необходимость в объекте. Рассмотрим редактор документов, в котором в документы могут встраиваться графические объекты. Затраты на создание некоторых таких объектов (например, больших растровых изображений) могут быть весьма значительными. Но документ должен открываться быстро, поэтому следует избегать создания всех «тяжелых» объектов на стадии открытия (и вообще это излишне, поскольку не все они будут видны одновременно).

В связи с такими ограничениями кажется разумным создавать «тяжелые» объекты *по требованию*. Это означает «когда изображение становится видимым». Но что поместить в документ вместо изображения? И как без усложнения реализации редактора скрыть тот факт, что изображение создается по требованию? Например, оптимизация не должна отражаться на коде, отвечающем за рисование и форматирование.

Решение состоит в том, чтобы использовать другой объект — *заместитель* изображения, который временно подставляется вместо реального изображения. Заместитель ведет себя точно так же, как само изображение, и при необходимости создает его экземпляр.

![image](https://user-images.githubusercontent.com/100960770/166919351-783120ed-0618-4417-bbf0-5d3f3b69826b.png)

**Заместитель** создает настоящее изображение, только если редактор документа вызовет операцию `Draw`. Все последующие запросы заместитель переадресует непосредственно изображению. Поэтому после создания изображения он должен сохранить ссылку на него.

Предположим, что изображения хранятся в отдельных файлах. В таком случае мы можем использовать имя файла как ссылку на реальный объект. Заместитель хранит также размер изображения, то есть длину и ширину. «Зная» ее, заместитель может отвечать на запросы форматера о своем размере, не создавая экземпляр изображения.

На следующей диаграмме классов этот пример показан более подробно.

![image](https://user-images.githubusercontent.com/100960770/166919456-201bbe8a-880f-4849-9a3e-8ad58fbcaca2.png)

Редактор документов получает доступ к встроенным изображениям только через интерфейс, определенный в абстрактном классе `Graphic`. `ImageProxy` — это класс для представления изображений, создаваемых по требованию. В `ImageProxy` хранится имя файла, играющее роль ссылки на изображение, которое находится на диске. Имя файла передается конструктору класса `ImageProxy`.

В объекте `ImageProxy` находятся также ограничивающий прямоугольник изображения и ссылка на экземпляр реального объекта `Image`. Ссылка остается недействительной, пока заместитель не создаст экземпляр реального изображения. Операция `Draw` гарантирует, что изображение будет создано до того, как заместитель переадресует ему запрос. Операция `GetExtent` переадресует запрос изображению, только если его экземпляр уже создан; в противном случае `ImageProxy` возвращает те размеры, которые хранит сам.

## Применимость

Паттерн **заместитель** применим во всех случаях, когда возникает необходимость сослаться на объект более гибким или нетривиальным способом, чем при использовании простого указателя. Несколько типичных ситуаций, в которых **заместитель** может оказаться полезным:

* *удаленный заместитель* предоставляет локального представителя для объекта, находящегося в другом адресном пространстве. В системе NEXTSTEP \[Add94\] для этой цели применяется класс `NXProxy`. Заместителя такого рода Джеймс Коплиен \[Cop92\] называет «послом» (Ambassador);
* *виртуальный заместитель* создает «тяжелые» объекты по требованию. Примером может служить класс `ImageProxy`, описанный в разделе [«Мотивация»](#мотивация);
* *защищающий заместитель* контролирует доступ к исходному объекту. Такие заместители полезны, когда для разных объектов определены различные права доступа. Например, в операционной системе Choices \[CIRM93\] объекты `KernelProxy` ограничивают права доступа к объектам операционной системы;
* *«умная» ссылка* — это замена обычного указателя. Она позволяет выполнить дополнительные действия при доступе к объекту. К типичным применениям такой ссылки можно отнести:

	* подсчет числа ссылок на реальный объект, с тем чтобы занимаемую им память можно было освободить автоматически, когда не останется ни одной ссылки (такие ссылки называют еще «умными» указателями \[Ede92\]);
	* загрузку объекта из долгосрочного хранилища в память при первом обращении к нему;
	* проверку и установку блокировки на реальный объект при обращении к нему, чтобы никакой другой объект не смог в это время изменить его.

## Структура

![image](https://user-images.githubusercontent.com/100960770/166919587-4cb32176-7ef2-4b6a-9f68-3385cc620386.png)

Вот как может выглядеть схема объектов для структуры с заместителем во время выполнения.

![image](https://user-images.githubusercontent.com/100960770/166919660-99e6080a-170b-444a-94de-ab7a51b15f05.png)

## Участники

* **Proxy** (`ImageProxy`) — заместитель:

	* хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту. Объект класса `Proxy` может обращаться к объекту класса `Subject`, если интерфейсы классов `RealSubject` и `Subject` одинаковы;
	* предоставляет интерфейс, идентичный интерфейсу `Subject`, так что заместитель всегда может быть подставлен вместо реального субъекта;
	* контролирует доступ к реальному субъекту и может отвечать за его создание и удаление;
	* прочие обязанности зависят от вида заместителя:

		* *удаленный заместитель* отвечает за кодирование запроса и его аргументов и отправление закодированного запроса реальному субъекту в другом адресном пространстве;
		* *виртуальный заместитель* может кэшировать дополнительную информацию о реальном субъекте, чтобы отложить его создание. Например, класс `ImageProxy` из раздела [«Мотивация»](#мотивация) кэширует размеры реального изображения;
		* *защищающий заместитель* проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права;

* **Subject** (`Graphic`) — субъект:

	* определяет общий для `RealSubject` и `Proxy` интерфейс, так что класс `Proxy` можно использовать везде, где ожидается `RealSubject`;

* **RealSubject** (`Image`) — реальный субъект:

	* определяет реальный объект, представленный заместителем.

## Отношения

`Proxy` при необходимости переадресует запросы объекту `RealSubject`. Детали зависят от вида заместителя.

## Результаты

С помощью паттерна **заместитель** при доступе к объекту вводится дополнительный уровень косвенности. У этого подхода есть много вариантов в зависимости от вида заместителя:

* удаленный заместитель может скрыть тот факт, что объект находится в другом адресном пространстве
* виртуальный заместитель может выполнять оптимизацию, например создание объекта по требованию;
* защищающий заместитель и «умная» ссылка позволяют решать дополнительные задачи при доступе к объекту.

Есть еще одна оптимизация, которую паттерн **заместитель** иногда скрывает от клиента. Она называется *копированием при записи* (copy-on-write) и имеет много общего с созданием объекта по требованию. Копирование большого и сложного объекта — очень затратная операция. Если копия не модифицировалась, то нет смысла эту цену платить. Если отложить процесс копирования, применив паттерн **заместитель**, то можно быть уверенным, что эта операция произойдет только тогда, когда он действительно был изменен.

Чтобы во время записи можно было копировать, необходимо подсчитывать ссылки на субъект. Копирование заместителя просто увеличивает счетчик ссылок. И только тогда, когда клиент запрашивает операцию, изменяющую субъект, заместитель действительно выполняет копирование. Одновременно заместитель должен уменьшить счетчик ссылок. Когда счетчик ссылок становится равным нулю, субъект уничтожается.

Копирование при записи может существенно уменьшить плату за копирование «тяжелых» субъектов.

## Реализация

При реализации паттерна заместитель можно использовать следующие возможности языка:

*	*перегрузку оператора обращения к членам класса в C++*. Язык C++ поддерживает перегрузку оператора обращения к членам класса `->`. Это позволяет производить дополнительные действия при любом разыменовании указателя на объект. Для реализации некоторых видов заместителей это оказывается полезно, поскольку заместитель ведет себя аналогично указателю.

	В следующем примере показано, как воспользоваться данным приемом для реализации виртуального заместителя `ImagePtr`:

	```cpp
	class Image;
	extern Image* LoadAnImageFile(const char*);
		// внешняя функция
	
	class ImagePtr {
	public:
		ImagePtr(const char* imageFile);
		virtual ~ImagePtr();
		virtual Image* operator->();
		virtual Image& operator*();
	private:
		Image* LoadImage();
	private:
		Image* _image;
		const char* _imageFile;
	};

	ImagePtr::ImagePtr(const char* theImageFile) {
		_imageFile = theImageFile;
		_image = 0;
	}

	Image* ImagePtr::LoadImage () {
		if (_image == 0) {
			_image = LoadAnImageFile(_imageFile);
		}
 	return _image;
	} 
	```

	Перегруженные операторы `->` и `*` используют операцию `LoadImage` для возврата клиенту изображения, хранящегося в переменной `_image` (при необходимости загрузив его):

	```cpp
	Image* ImagePtr::operator-> () {
		return LoadImage();
	}

	Image& ImagePtr::operator* () {
		return *LoadImage();
	}
	```

	Такой подход позволяет вызывать операции объекта `Image` через объекты `ImagePtr`, не заботясь о том, чтобы включить их в интерфейс данного класса:

	```cpp
	ImagePtr image = ImagePtr("anImageFileName");
	image->Draw(Point(50, 100));
		// (image.operator->())->Draw(Point(50, 100)
	```

	Обратите внимание, что заместитель изображения ведет себя подобно указателю, но не объявлен как указатель на `Image`. Это означает, что использовать его в точности как настоящий указатель на `Image` нельзя. Поэтому при таком подходе клиентам следует трактовать объекты `Image` и `ImagePtr` по-разному.

	Перегрузка оператора доступа не является лучшим решением для всех видов заместителей. Некоторым из них должно быть точно известно, *какая* операция вызывается, а в таких случаях перегрузка оператора доступа не работает.

	Возьмем пример виртуального заместителя, обсуждавшийся в разделе [«Мотивация»](#мотивация). Изображение нужно загружать в точно определенное время — при вызове операции `Draw`, а не при каждом обращении к нему.

	Перегрузка оператора доступа не позволяет различить подобные случаи. В такой ситуации придется вручную реализовать каждую операцию заместителя, переадресующую запрос субъекту.

	Обычно все эти операции очень похожи друг на друга, как видно из примера кода в одноименном разделе. Они проверяют, что запрос корректен, что объект-адресат существует и т. д., а потом уже перенаправляют ему запрос. Писать этот код снова и снова надоедает, поэтому нередко он автоматически генерируется препроцессором;

*	*метод doesNotUnderstand в Smalltalk*. В языке Smalltalk есть возможность, позволяющая автоматически поддерживать переадресацию запросов. При отправке клиентом сообщения, для которого у получателя нет соответствующего метода, Smalltalk вызывает метод `doesNotUnderstand: aMessage`. Заместитель может переопределить `doesNotUnderstand` так, что сообщение будет переадресовано субъекту.

	Чтобы гарантировать, что запрос будет перенаправлен субъекту, а не просто тихо поглощен заместителем, класс `Proxy` можно определить так, что он не станет понимать никаких сообщений. Smalltalk позволяет это сделать, надо лишь, чтобы у `Proxy` не было суперкласса.

	> Этот прием используется при реализации распределенных объектов в системе NEXTSTEP \[Add94\] (точнее, в классе `NXProxy`). Только там переопределяется метод `forward` — эквивалент описанного только что приема в Smalltalk.

	Главный недостаток метода `doesNotUnderstand`: в том, что в большинстве Smalltalk-систем имеется несколько специальных сообщений, обрабатываемых непосредственно виртуальной машиной, а в этом случае стандартный механизм поиска методов обходится. Правда, единственной такой операцией, написанной в классе `Object` (а следовательно, способной повлиять на заместителей), является тождество `==`.
	
	Если вы собираетесь применять `doesNotUnderstand`: для реализации заместителя, вышеописанная проблема должна быть как-то решена на уровне проектирования. Нельзя же ожидать, что совпадение заместителей равнозначно совпадению реальных субъектов. К сожалению, метод `doesNotUnderstand`: изначально создавался для обработки ошибок, а не для построения заместителей, поэтому его быстродействие оставляет желать лучшего;

*	*заместителю не всегда должен быть известен тип реального объекта*. Если класс `Proxy` может работать с субъектом только через его абстрактный интерфейс, то не нужно создавать Proxy для каждого класса реального субъекта `RealSubject`; заместитель может обращаться к любому из них единообразно. Но если заместитель должен создавать экземпляры реальных субъектов (как обстоит дело в случае виртуальных заместителей), то знание конкретного класса обязательно.

К проблемам реализации можно отнести и решение вопроса о том, как обращаться к субъекту, экземпляр которого еще не создан. Некоторые заместители должны обращаться к своим субъектам независимо от того, где они находятся — на диске или в памяти. Это означает, что нужно использовать какую-то форму идентификаторов объектов, не зависящих от адресного пространства. В разделе «Мотивация» для этой цели использовалось имя файла.

## Пример кода

В следующем коде реализованы два вида заместителей: виртуальный, описанный в разделе [«Мотивация»](#мотивация), и реализованный с помощью метода
`doesNotUnderstand`:

> Еще один вид заместителя дает паттерн **итератор**.

*	*виртуальный заместитель*. В классе `Graphic` определен интерфейс для
графических объектов:

	```cpp
	class Graphic {
	public:
		virtual ~Graphic();

		virtual void Draw(const Point& at) = 0;
		virtual void HandleMouse(Event& event) = 0;

		virtual const Point& GetExtent() = 0;

		virtual void Load(istream& from) = 0;
		virtual void Save(ostream& to) = 0;
	protected:
		Graphic();
	};
	```

	Класс `Image` реализует интерфейс `Graphic` для отображения графических файлов. В нем замещается операция `HandleMouse`, при помощи которой пользователь может интерактивно изменять размер изображения:

	```cpp
	class Image : public Graphic {
	public:
		Image(const char* file); // Загружает изображение из файла
		virtual ~Image();
		virtual void Draw(const Point& at);
		virtual void HandleMouse(Event& event);
		virtual const Point& GetExtent();
		virtual void Load(istream& from);
		virtual void Save(ostream& to);
	private:
		// ...
	};
	```

	Класс `ImageProxy` имеет тот же интерфейс, что и `Image`:

	```cpp
	class ImageProxy : public Graphic {
	public:
		ImageProxy(const char* imageFile);
		virtual ~ImageProxy();

		virtual void Draw(const Point& at);
		virtual void HandleMouse(Event& event);

		virtual const Point& GetExtent();

		virtual void Load(istream& from);
		virtual void Save(ostream& to);
	protected:
		Image* GetImage();
	private:
		Image* _image;
		Point _extent;
		char* _fileName;
	};
	```

	Конструктор сохраняет локальную копию имени файла, в котором хранится изображение, и инициализирует переменные `_extent` и `_image`:

	```cpp
	ImageProxy::ImageProxy (const char* fileName) {
		_fileName = strdup(fileName);
		_extent = Point::Zero; // размеры пока не известны
		_image = 0;
	}

	Image* ImageProxy::GetImage() {
		if (_image == 0) {
			_image = new Image(_fileName);
		}
		return _image;
	}
	```

	Реализация операции `GetExtent` возвращает кэшированный размер, если это возможно. В противном случае изображение загружается из файла. Операция `Draw` загружает изображение, а `HandleMouse` перенаправляет событие реальному изображению:

	```cpp
	const Point& ImageProxy::GetExtent () {
		if (_extent == Point::Zero) {
			_extent = GetImage()->GetExtent();
		}
		return _extent;
	}

	void ImageProxy::Draw (const Point& at) {
		GetImage()->Draw(at);
	}

	void ImageProxy::HandleMouse (Event& event) {
		GetImage()->HandleMouse(event);
	}
	```

	Операция `Save` записывает кэшированный размер изображения и имя файла в поток, а `Load` считывает эту информацию и инициализирует соответствующие переменные:

	```cpp
	void ImageProxy::Save (ostream& to) {
		to << _extent << _fileName;
	}

	void ImageProxy::Load (istream& from) {
		from >> _extent >> _fileName;
	}
	```

	Наконец, предположим, что есть класс `TextDocument` для представления документа, который может содержать объекты класса `Graphic`:

	```cpp
	class TextDocument {
	public:
		TextDocument();

		void Insert(Graphic*);
		// ...
	};
	```

	Объект `ImageProxy` можно вставить в документ следующим образом:

	```cpp
	TextDocument* text = new TextDocument;
	// ...
	text->Insert(new ImageProxy("anImageFileName"));
	```

*	*заместители, использующие метод doesNotUnderstand*. В языке Smalltalk можно создавать обобщенных заместителей, определяя классы, не имеющие суперкласса, а в них — метод `doesNotUnderstand`: для обработки сообщений.

	> Практически для любого класса `Object` является суперклассом самого верхнего уровня. Поэтому выражение «нет суперкласса» означает то же самое, что «определение класса, для которого `Object` не является суперклассом».

	В показанном ниже фрагменте предполагается, что у заместителя есть метод `realSubject`, возвращающий связанный с ним реальный субъект. При использовании `ImageProxy` этот метод должен был бы проверить, создан ли объект `Image`, при необходимости создать его и затем вернуть. Для обработки перехваченного сообщения, которое было адресовано реальному субъекту, используется метод `perform:withArguments`:.

	```smalltalk
	doesNotUnderstand: aMessage
		^ self realSubject
			perform: aMessage selector
			withArguments: aMessage arguments
	```

	Аргументом `doesNotUnderstand:` является экземпляр класса `Message`, представляющий сообщение, не понятое заместителем. Таким образом, при ответе на любое сообщение заместитель сначала проверяет, что реальный субъект существует, а потом уже переадресует ему сообщение.

	Одно из преимуществ метода `doesNotUnderstand:` — возможность выполнения произвольной обработки. Например, можно было бы создать защищающего заместителя, определив набор `legalMessages`-сообщений, которые следует принимать, и передав заместителю следующий метод:

	```smalltalk
	doesNotUnderstand: aMessage
		^ (legalMessages includes: aMessage selector)
			ifTrue: [self realSubject
				perform: aMessage selector
				withArguments: aMessage arguments]
			ifFalse: [self error: 'Illegal operator']
	```

	Прежде чем переадресовать сообщение реальному субъекту, указанный метод проверяет, что оно действительно. Если это не так, `doesNotUnderstand:` посылает сообщение `error:` самому себе, что приведет к зацикливанию, если в заместителе не определен метод `error:`. Следовательно, определение error: должно быть скопировано из класса `Object` вместе со всеми методами, которые в нем используются.

## Известные применения

Пример виртуального заместителя из раздела [«Мотивация»](#мотивация) заимствован из классов строительного блока текста, определенных в каркасе ET++.

В системе NEXTSTEP \[Add94\] заместители (экземпляры класса `NXProxy`) используются как локальные представители объектов, которые могут быть распределенными. Сервер создает заместителей для удаленных объектов, когда клиент их запрашивает. Заместитель кодирует полученное сообщение вместе со всеми аргументами, после чего отправляет его удаленному субъекту. Аналогично субъект кодирует возвращенные результаты и посылает их обратно объекту `NXProxy`.

В работе McCullough \[McC87\] обсуждается применение заместителей в Smalltalk для обращения к удаленным объектам. Джефри Пэско (Geoffrey Pascoe) \[Pas86\] описывает, как обеспечить побочные эффекты при вызове методов и реализовать контроль доступа с помощью «инкапсуляторов».

## Родственные паттерны

**Адаптер**: предоставляет другой интерфейс к адаптируемому объекту. Напротив, заместитель в точности повторяет интерфейс своего субъекта. Однако, если заместитель используется для ограничения доступа, он может отказаться выполнять операцию, которую субъект выполнил бы, поэтому на самом деле интерфейс заместителя может быть и подмножеством интерфейса субъекта.

**Декоратор**: хотя его реализация и похожа на реализацию заместителя, но назначение совершенно иное. Декоратор добавляет объекту новые обязанности, а заместитель контролирует доступ к объекту.

Степень схожести реализации заместителей и декораторов может быть различной. Защищающий заместитель мог бы быть реализован в точности как декоратор. С другой стороны, удаленный заместитель не содержит прямых ссылок на реальный субъект, а лишь косвенную ссылку, что-то вроде «идентификатор хоста и локальный адрес на этом хосте». Вначале виртуальный заместитель имеет только косвенную ссылку (скажем, имя файла), но в конечном итоге получает и использует прямую ссылку.
